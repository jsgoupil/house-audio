<!DOCTYPE html>
<html>
<head>
<title></title>
<style>

.fx-scrollbar
{
  -ms-user-select: none;
  -ms-touch-action: none;
 }

 
.fx-scrollbar {
    overflow: hidden;
    position: relative;
}

.fx-scrollbar .fx-scrollbar-track {
    position: absolute;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    cursor: default;
}

.fx-scrollbar .fx-scrollbar-track.fx-scrollbar-track-horizontal {
    height: 8px;
    left: 2px;
    bottom: 0;
    right: 2px;
    background-color: #ccc;
}

.fx-scrollbar .fx-scrollbar-track.fx-scrollbar-track-vertical {
    width: 8px;
    top: 2px;
    right: 0;
    bottom: 2px;
    background-color: #ccc;
}

.fx-scrollbar .fx-scrollbar-track .fx-scrollbar-handle {
    position: absolute;
    background-color: #666;
}

.fx-scrollbar .fx-scrollbar-track.fx-scrollbar-track-horizontal .fx-scrollbar-handle {
    height: 8px;
    bottom: 0;
}

.fx-scrollbar .fx-scrollbar-track.fx-scrollbar-track-vertical .fx-scrollbar-handle {
    width: 8px;
    right: 0;
}
</style>
<script src="http://code.jquery.com/jquery-1.7.1.js"></script>
<script src="http://code.jquery.com/ui/1.8.19/jquery-ui.js"></script>
<script>
/// <dependency type="css" file="fx.scrollbar.css" />
/// <dependency type="js" file="fx.utilities.js" />

(function($, parentWidget, global, undefined) {
    "use strict";

    var base = parentWidget.prototype,
        calls = {
            vertical: {
                scrollPosition: "scrollTop",
                scrollSize: "scrollHeight",
                clientSize: "clientHeight",
                page: "pageY",
                position: "top",
                size: "height",
                orientation: "vertical"
            },
            horizontal: {
                scrollPosition: "scrollLeft",
                scrollSize: "scrollWidth",
                clientSize: "clientWidth",
                page: "pageX",
                position: "left",
                size: "width",
                orientation: "horizontal"
            }
        };

    /// <summary>
    /// Changes the default style of a system scrollbar.
    /// Your element will be wrapped inside two elements. In order to obtain the outer element, call the "widget" method.
    /// The following styles are being transferred to the outer element:
    ///   * margin
    ///   * border
    ///   * float
    ///   * position
    ///   * top/right/bottom/left
    /// </summary>
    $.widget("fx.fxScrollbar", parentWidget, {
        options: {
            /// <option type="Number">
            /// Polls the content area at specific intervals to see if the size has changed. If it has, refresh is called.
            /// Time in milliseconds. Set 0 to deactivate. Default value 0.
            /// Whenever possible, it is recommended to leave this value as 0 and call refresh when the content changes.
            /// </option>
            autorefresh: 0,

            /// <option type="Boolean">
            /// If true, indicates that we should add 'fx-scrollbar-animated' in addition to 'fx-scrollbar'.
            /// </option>
            animated: false,

            /// <option type="Boolean">
            /// If true, you indicate the scrollbar that the size will not change if the content changes.
            /// It will improve the speed of the control since there is no need to recalculate that possible change
            /// everytime there is a refresh.
            /// Set to false if your control changes its size based on its content OR the resizing of the window.
            /// </option>
            isStaticContainerSize: false
        },

        _widget: null,

        _overflowProperties: null,
        _savedProperties: null,
        _scrollingObjectCache: null,
        _trackEnter: false,

        _resizeHandler: null,
        _autoRefreshInterval: null,
        _autoRefreshWidth: -1,
        _autoRefreshHeight: -1,
        _minimumScrollbarSize: 15,
        _scrollWheelSensitivity: 50,

        _resizeTimerHandle: null,

        _bars: null,
        _track: null,
        _ratio: null,

        _isResizing: false,
        _isRefreshing: false,

        _readyForTrackClick: false,


            
            _eventScroll: null,
            _eventMouseWheel: null,
            _eventDOMMouseScroll: null,
            _eventTouchStart: null,
            _eventTouchMove: null,
            _eventTouchEnd: null,
            _eventMSPointerDown: null,
            _eventMSGestureChange: null,

        _create: function() {
            var that = this;
            
            // Don't accept true, must specify a number
            if (typeof this.options.autorefresh !== "number") {
                throw "AutoRefresh must be a number in milliseconds";
            }

            this._bars = {
                vertical: {},
                horizontal: {}
            };
            
            this._ratio = {};

            this._overflowProperties = this._eraseOverflowProperties(this.element);

            this._portScroll(function() {
                return that._attachScrollable();
            });

            this._resizeHandler = function() { that._resize.apply(that, arguments); };
            $(global).on("resize", this._resizeHandler);

            this._attachElementEvents(this.element);
            // this._attachScrollEvent(this._scrollableArea);
            /*
            if (this.options.autorefresh > 0) {
                this._autoRefreshWidth = this.element[0].scrollWidth;
                this._autoRefreshHeight = this.element[0].scrollHeight;
                this._autoRefreshInterval = global.setInterval($.proxy(this._autoRefresh, this), this.options.autorefresh);
            }
            */
        },

        widget: function() {
            /// <summary>Gets the element's widget. You must use that object if you wish to change its style.</summary>
            /// <returns type="jQuery" />

            return this._widget || this.element;
        },

        destroy: function() {
            /// <summary>Destroys the widget.</summary>

            this._detachElementEvents();

            if (this._autoRefreshInterval) {
                global.clearInterval(this._autoRefreshInterval);
                this._autoRefreshInterval = null;
            }

            this._portScroll($.proxy(function() {
                this._resetStyle();
                return null;
            }, this));

            if (this._resizeHandler !== null) {
                $(global).off("resize", this._resizeHandler);
                this._resizeHandler = null;
            }

            this.element.off(".fxScrollbar");

            $.Widget.prototype.destroy.call(this);
        },

        refresh: function(force) {
            /// <summary>
            /// Refreshes the scrollbar by recalculating the content size and drawing the scrollbar again.
            /// </summary>
            /// <param name="force" type="Boolean" optional="true">
            /// Forces a full refresh causing wrap/unwrap of your element. This parameter is used only if you set
            /// the option isStaticContainerSize to true. By default, this parameter is false.
            /// </param>

            // IE8 has a problem with the callstack and might call a resize handle while the refresh is being run.
            if (!this._isRefreshing) {
                this._isRefreshing = true;
                this._portScroll($.proxy(function() {
                    var scrollingObject;
                    if (this.options.isStaticContainerSize && !force) {
                        scrollingObject = this._getScrollingObjectFromFixedSize();
                        this._positionTrack(this._widget.width(), this._widget.height(), scrollingObject);
                        return scrollingObject;
                    } else {
                        this._resetStyle();
                        return this._attachScrollable();
                    }
                }, this));
                this._isRefreshing = false;
            }
        },

        scrollTop: function(value) {
            /// <summary>
            ///     1: Gets the current vertical position of the scrollbar.
            ///     &#10;    1.1 - scrollTop()
            ///     &#10;2: Sets the current vertical position of the scrollbar.
            ///     &#10;    2.1 - scrollTop(value)
            /// </summary>
            /// <param name="value" type="Number">
            ///     An integer indicating the new position to set the scrollbar to.
            /// </param>
            /// <returns type="Number" />

            if (value === undefined) {
                return this.element.scrollTop();
            }

            this.element.scrollTop(value);
        },

        /* OK */
        scrollLeft: function(value) {
            /// <summary>
            ///     1: Gets the current horizontal position of the scrollbar.
            ///     &#10;    1.1 - scrollLeft()
            ///     &#10;2: Sets the current horizontal position of the scrollbar.
            ///     &#10;    2.1 - scrollLeft(value)
            /// </summary>
            /// <param name="value" type="Number">
            ///     An integer indicating the new position to set the scrollbar to.
            /// </param>
            /// <returns type="Number" />

            if (value === undefined) {
                return this.element.scrollLeft();
            }

            this.element.scrollLeft(value);
        },
        
        scrollIntoView: function(element, alignToTop) {
            var $element = $(element),
                foundElementOffset, elementOffset, finalY, finalX;
            if ($.contains(this.element[0], $element[0])) {
                foundElementOffset = $element.offset();
                elementOffset = this.element.offset();
                
                finalY = foundElementOffset.top - elementOffset.top + this.element.scrollTop();
                finalX = foundElementOffset.left - elementOffset.left + this.element.scrollLeft();
                if (!alignToTop) { // TODO Check with left??
                    finalY -= (this.element.outerHeight() - $element.outerHeight());
                }
                
                this.element.scrollTop(finalY);
                this.element.scrollLeft(finalX);
            }
        },

        _portScroll: function(callback) {
            var element = this.element,
                currentScrollLeft = element.scrollLeft(),
                currentScrollTop = element.scrollTop(),
                activeElement = global.document.activeElement,
                scrollableProperties = callback(currentScrollLeft, currentScrollTop);

            if ($.contains(this.element[0], activeElement)) {
                activeElement.focus();
            }

            element
                .scrollLeft(currentScrollLeft)
                .scrollTop(currentScrollTop)
                .scroll();

                // TODO Show the tracks
        },
        
        /* OK */
        _detachElementEvents: function() {
            if (this._eventScroll) {
                this.element.off("scroll.fxScrollbar", this._eventScroll);
                this._eventScroll = null;
            }
            if (this._eventMouseWheel) {
                this.element.off("mousewheel.fxScrollbar", this._eventMouseWheel);
                this._eventMouseWheel = null;
            }
            if (this._eventDOMMouseScroll) {
                this.element.off("DOMMouseScroll.fxScrollbar", this._eventDOMMouseScroll);
                this._eventDOMMouseScroll = null;
            }
            if (this._eventTouchStart) {
                this.element.off("touchstart.fxScrollbar", this._eventTouchStart);
                this._eventTouchStart = null;
            }
            if (this._eventTouchMove) {
                this.element.off("touchmove.fxScrollbar", this._eventTouchMove);
                this._eventTouchMove = null;
            }
            if (this._eventTouchEnd) {
                this.element.off("toucheend.fxScrollbar", this._eventTouchEnd);
                this._eventTouchEnd = null;
            }
            if (this._eventMSPointerDown) {
                this.element.off("MSPointerDown.fxScrollbar", this._eventMSPointerDown);
                this._eventMSPointerDown = null;
            }
            if (this._eventMSGestureChange) {
                this.element.off("MSGestureChange.fxScrollbar", this._eventMSGestureChange);
                this._eventMSGestureChange = null;
            }
        },
        
        /* OK */
        _attachElementEvents: function() {
            var that = this,
                gesture,
                moveStartPosition,
                isValidScroll = function(scrollTop, scrollLeft) {
                    // Prevent the default if you actually did something
                    // If we are at the top or bottom of the scrolling, we let the event go
                    
                    return scrollTop >= 0 && scrollLeft >= 0
                        && scrollTop <= that.element[0].scrollHeight - that.element[0].clientHeight
                        && scrollLeft <= that.element[0].scrollWidth - that.element[0].clientWidth;
                };
            
            if (global.MSGesture) { // TouchScreen: IE10 Gesture
                gesture = new global.MSGesture();
                gesture.target = this.element[0];
            }
            
            this._detachElementEvents();
            this.element
                .on("scroll.fxScrollbar", this._eventScroll = function() {
                    that._createOrUpdateTracks();
                })
                .on("mousewheel.fxScrollbar", this._eventMouseWheel = function(evt) { // Wheel: Chrome & IE
                    var originalEvent = evt.originalEvent,
                        deltaY = 0, deltaX = 0, scrollTop, scrollLeft;
                    if (originalEvent.wheelDeltaY) {
                        deltaY = originalEvent.wheelDeltaY / 120;
                    }
                    if (originalEvent.wheelDeltaX) {
                        deltaX = originalEvent.wheelDeltaX / 120;
                    }
                    if (!deltaY && !deltaX && originalEvent.wheelDelta) {
                        deltaY = originalEvent.wheelDelta / 120;
                    }
                    
                    scrollTop = that.element.scrollTop() - deltaY * that._scrollWheelSensitivity;
                    scrollLeft = that.element.scrollLeft() - deltaX * that._scrollWheelSensitivity;
                    
                    that.element.scrollTop(scrollTop);
                    that.element.scrollLeft(scrollLeft);
                    
                    if (isValidScroll(scrollTop, scrollLeft)) {
                        evt.preventDefault();
                    }
                })
                .on("DOMMouseScroll.fxScrollbar", this._eventDOMMouseScroll = function(evt) { // Wheel: Firefox
                    var originalEvent = evt.originalEvent,
                        scrollTop, scrollLeft;
                    if (originalEvent.axis === evt.originalEvent.VERTICAL_AXIS) {
                        scrollTop = that.element.scrollTop() - (-originalEvent.detail / 3) * that._scrollWheelSensitivity;
                    }
                    if (originalEvent.axis === evt.originalEvent.HORIZONTAL_AXIS) {
                        scrollLeft = that.element.scrollLeft() - (-originalEvent.detail / 3) * that._scrollWheelSensitivity;
                    }
                    
                    if (scrollTop !== undefined) {
                        that.element.scrollTop(scrollTop);
                    }
                    if (scrollLeft !== undefined) {
                        that.element.scrollLeft(scrollLeft);
                    }
                    
                    if (isValidScroll(scrollTop || 0, scrollLeft || 0)) {
                        evt.preventDefault();
                    }
                })
                .on("touchstart.fxScrollbar", this._eventTouchStart = function(evt) { // TouchScreen: Chrome & Firefox
                    var originalEvent = evt.originalEvent;
                    if (originalEvent.targetTouches.length === 1) {
                        moveStartPosition = { top: originalEvent.targetTouches[0].clientY, left: originalEvent.targetTouches[0].clientX };
                    }
                })
                .on("touchmove.fxScrollbar", this._eventTouchMove = function(evt) { // TouchScreen: Chrome & Firefox
                    var originalEvent = evt.originalEvent;
                    // We act when we have only one touch
                    if (originalEvent.targetTouches.length === 1 && moveStartPosition) {
                        that.element.scrollTop(that.element.scrollTop() - (originalEvent.targetTouches[0].clientY - moveStartPosition.top));
                    }
                    
                    evt.preventDefault();
                })
                .on("touchend.fxScrollbar", this._eventTouchEnd = function(evt) {
                    moveStartPosition = null;
                })
                .on("MSPointerDown.fxScrollbar", this._eventMSPointerDown = function(evt) {
                    var originalEvent = evt.originalEvent;
                    gesture.addPointer(originalEvent.pointerId);
                })
                .on("MSGestureChange.fxScrollbar", this._eventMSGestureChange = function(evt) {
                    var originalEvent = evt.originalEvent;
                    that.element.scrollTop(that.element.scrollTop() - originalEvent.translationY);
                    that.element.scrollLeft(that.element.scrollLeft() - originalEvent.translationX);
                });
        },

        _createOrUpdateTracks: function() {
            this._createOrUpdateTrack(calls.vertical);
            this._createOrUpdateTrack(calls.horizontal);
        },

        _createOrUpdateTrack: function(kind) {
            var domElement = this.element[0],
                bar = this._bars[kind.orientation],
                scrollingObject = this._getScrollingObject(this.element);

            this._createTrack(kind);
            if (scrollingObject[kind.orientation]) {
                this._setHandleSize(bar.handle, 0, kind);

                if (!bar.attached) {
                    this._widget.append(bar.track);
                    bar.attached = true;
                }
            } else {
                if (bar.attached) {
                    bar.track.detach();
                    bar.attached = false;
                }
            }
        },

        _createTrack: function(kind) {
            var that = this;
            if (!this._bars[kind.orientation].track) {
                this._bars[kind.orientation].track = $("<div />")
                    .addClass("fx-scrollbar-track")
                    .addClass("fx-scrollbar-track-" + kind.orientation)
                    .on("mouseenter", function() { that._trackEnter = true; })
                    .on("mouseleave", function() { that._trackEnter = false; });

                this._bars[kind.orientation].handle = $("<div />")
                    .addClass("fx-scrollbar-handle");

                this._bars[kind.orientation].track.append(this._bars[kind.orientation].handle);
            }
        },

        _autoRefresh: function() {
            if (this.element[0].scrollWidth !== this._autoRefreshWidth || this.element[0].scrollHeight !== this._autoRefreshHeight) {
                this._autoRefreshWidth = this.element[0].scrollWidth;
                this._autoRefreshHeight = this.element[0].scrollHeight;
                this.refresh();
            }
        },

        _resetStyle: function() {
            if (this._savedProperties) {
                this._transferOverflowProperties(this.element, this._savedProperties);
                this._transferGlobalProperties(this.element, this._savedProperties);
                this.element.css({
                    width: this._savedProperties.fluidW ? "" : this._savedProperties.cssWidth,
                    height: this._savedProperties.fluidH ? "" : this._savedProperties.cssHeight
                });
            }

            // Detach the track before we unwrap
            this._detachTrack();
            this.element.unwrap().unwrap();
            this._widget = null;
        },

        _attachScrollable: function() {       
            var realWidth = this.element.width(),
                realHeight = this.element.height(),
                scrollingObject = this._getScrollingObject(this.element, true);

            // Wrap the element and save variables
            this.element.wrap(
                $("<div />")
                    .addClass("fx-scrollbar")
                    .addClass("fx-scrollbar-animated", this.options.animated)
            );
            this._widget = this.element.parent();

            // Transfer some properties
            this._savedProperties = this._getProperties(this.element);
            $.extend(this._savedProperties, this._eraseGlobalProperties(this.element));

            // Set the big parent to a fixed size
            this._widget
            //    .width(realWidth)
            //    .height(realHeight);
            this._transferGlobalProperties(this._widget, this._savedProperties);

            // Make sure we don't transfer static
            if (this._savedProperties.position === "static") {
                this._widget.css("position", "");
            }

            this._createOrUpdateTracks();
            
            this._attachWidgetEvents();

            return scrollingObject;
        },
        
        _attachWidgetEvents: function() {
            var that = this;
            this._widget
                .on("mousedown.fxScrollbar", ".fx-scrollbar-track-horizontal .fx-scrollbar-handle", this._getHandleHandler(this, calls.horizontal))
                .on("mousedown.fxScrollbar", ".fx-scrollbar-track-vertical .fx-scrollbar-handle", this._getHandleHandler(this, calls.vertical))
                .on("click.fxScrollbar", ".fx-scrollbar-handle", function() { return false; })
                .on("mousedown.fxScrollbar", ".fx-scrollbar-track-horizontal", this._getTrackHandler(this, calls.horizontal))
                .on("mousedown.fxScrollbar", ".fx-scrollbar-track-vertical", this._getTrackHandler(this, calls.vertical));
        },

        _getProperties: function(from) {
            var savedProperties = {
                cssWidth: from[0].style.width,
                cssHeight: from[0].style.height,
                fluidW: from[0].style.width === "",
                fluidH: from[0].style.height === ""
            };

            return savedProperties;
        },

        _eraseOverflowProperties: function(from) {
            var properties = {
                overflowX: from.css("overflowX"),
                overflowY: from.css("overflowY")
            };

            from
                .css({
                    overflowX: "hidden",
                    overflowY: "hidden"
                });

            return properties;
        },

        _transferOverflowProperties: function(to, properties) {
            to
                .css({
                    overflowX: properties.overflowX,
                    overflowY: properties.overflowY
                });
        },

        _eraseGlobalProperties: function(from) {
            var maxHeight = from.css("max-height"),
                properties = {
                    marginTop: from.css("marginTop"),
                    marginRight: from.css("marginRight"),
                    marginBottom: from.css("marginBottom"),
                    marginLeft: from.css("marginLeft"),
                    borderTopWidth: from.css("borderTopWidth"),
                    borderTopColor: from.css("borderTopColor"),
                    borderTopStyle: from.css("borderTopStyle"),
                    borderRightWidth: from.css("borderRightWidth"),
                    borderRightColor: from.css("borderRightColor"),
                    borderRightStyle: from.css("borderRightStyle"),
                    borderBottomWidth: from.css("borderBottomWidth"),
                    borderBottomColor: from.css("borderBottomColor"),
                    borderBottomStyle: from.css("borderBottomStyle"),
                    borderLeftWidth: from.css("borderLeftWidth"),
                    borderLeftColor: from.css("borderLeftColor"),
                    borderLeftStyle: from.css("borderLeftStyle"),
                    position: from.css("position"),
                    top: from.css("top"),
                    right: from.css("right"),
                    bottom: from.css("bottom"),
                    left: from.css("left"),
                    float: from.css("float"),

                    // IE9 returns sometimes 0px instead of none
                    maxHeight: maxHeight === "0px" ? "none" : maxHeight
                };

            from
                .css({
                    margin: 0,
                    borderTopWidth: "0",
                    borderTopColor: "",
                    borderTopStyle: "",
                    borderRightWidth: "0",
                    borderRightColor: "",
                    borderRightStyle: "",
                    borderBottomWidth: "0",
                    borderBottomColor: "",
                    borderBottomStyle: "",
                    borderLeftWidth: "0",
                    borderLeftColor: "",
                    borderLeftStyle: "",
                    position: "static",
                    top: "",
                    right: "",
                    bottom: "",
                    left: "",
                    float: "",
                    "max-height": "none"
                });

            return properties;
        },

        _transferGlobalProperties: function(to, properties) {
            to
                .css({
                    marginTop: properties.marginTop,
                    marginRight: properties.marginRight,
                    marginBottom: properties.marginBottom,
                    marginLeft: properties.marginLeft,
                    borderTopWidth: properties.borderTopWidth,
                    borderTopColor: properties.borderTopColor,
                    borderTopStyle: properties.borderTopStyle,
                    borderRightWidth: properties.borderRightWidth,
                    borderRightColor: properties.borderRightColor,
                    borderRightStyle: properties.borderRightStyle,
                    borderBottomWidth: properties.borderBottomWidth,
                    borderBottomColor: properties.borderBottomColor,
                    borderBottomStyle: properties.borderBottomStyle,
                    borderLeftWidth: properties.borderLeftWidth,
                    borderLeftColor: properties.borderLeftColor,
                    borderLeftStyle: properties.borderLeftStyle,
                    position: properties.position,
                    top: properties.top,
                    right: properties.right,
                    bottom: properties.bottom,
                    left: properties.left,
                    float: properties.float,
                    maxHeight: properties.maxHeight
                });
        },

        _getScrollingObjectFromFixedSize: function() {
            var overflowX = this._scrollableArea.css("overflowX"),
                overflowY = this._scrollableArea.css("overflowY"),
                previousValue,
                obj = {
                    isHorizontalScrolling: false,
                    isVerticalScrolling: false
                };

            if (overflowX === "scroll") {
                obj.isHorizontalScrolling = true;
            } else if (overflowX === "auto") {
                previousValue = this.element.width();
                this.element.width("auto");
                obj.isHorizontalScrolling = this.element[0].scrollWidth > this._scrollableArea[0].clientWidth;
                this.element.width(previousValue);
            }

            if (overflowY === "scroll") {
                obj.isVerticalScrolling = true;
            } else if (overflowY === "auto") {
                previousValue = this.element.height();
                this.element.height("auto");
                obj.isVerticalScrolling = this.element[0].clientHeight > this._scrollableArea[0].clientHeight;
                this.element.height(previousValue);
            }

            return obj;
        },

        _getScrollingObject: function(element, recalculate) {
            if (recalculate || !this._scrollingObjectCache) {
                this._scrollingObjectCache = {
                    horizontal: this._isHorizontalScrolling(this._overflowProperties.overflowX, element),
                    vertical: this._isVerticalScrolling(this._overflowProperties.overflowY, element)
                };
            }
        
            return this._scrollingObjectCache;
        },

        _isVerticalScrolling: function(overflowY, element) {
            return this._isScrolling(overflowY, element, calls.vertical);
        },

        _isHorizontalScrolling: function(overflowX, element) {
            return this._isScrolling(overflowX, element, calls.horizontal);
        },

        _isScrolling: function(overflow, element, kind) {
            if (overflow === "scroll") {
                return true;
            }

            if (overflow === "hidden") {
                return false;
            }

            return element[0][kind.clientSize] < element[0][kind.scrollSize];
        },

        _attachScrollEvent: function(element) {
            var that = this;
            element
                .off("scroll.fxScrollbar")
                .on("mousewheel DOMMouseScroll.fxScrollbar", function() {
                alert('mousewheel');
                /*
                    var handleX = that._track.x.find(".fx-scrollbar-handle"),
                        handleY = that._track.y.find(".fx-scrollbar-handle");
                    handleX.css("left", $(this).scrollLeft() / that._ratio.width);
                    handleY.css("top", $(this).scrollTop() / that._ratio.height);

                    if (!that._isResizing && !that._isRefreshing) {
                        handleX.addClass("fx-scrollbar-onmousewheel");
                        handleY.addClass("fx-scrollbar-onmousewheel");
                        global.setTimeout(function() {
                            handleX.removeClass("fx-scrollbar-onmousewheel");
                            handleY.removeClass("fx-scrollbar-onmousewheel");
                        }, 0);
                    }
                    */
                });
        },

        _resize: function() {
            var that = this;
            if (this._resizeTimerHandle) {
                global.clearTimeout(this._resizeTimerHandle);
            }

            this._isResizing = true;
            this.refresh();

            // The scroll event could happen at any moment just after we exit this function
            // We make sure to set the variable _isResizing to false just a little later
            this._resizeTimerHandle = global.setTimeout(function() {
                that._isResizing = false;
            }, 10);
        },

        _setHandleSize: function(handle, oppositeSideTrack, kind) {
            // Our actual size is smaller if the opposite side is also scrolling because of the scrollbar.
            // clientSize is the size inside the scrollbars
            // TODO This ratio seems incorrect with 2 scrollbars?
            var fullSize = this.element[0][kind.scrollSize],
                actualSize = this._widget[0][kind.clientSize],
                scrollbarSize = Math.max(this._minimumScrollbarSize, (actualSize / fullSize) * (actualSize - oppositeSideTrack));

            // Subtract 4 pixels. 2 pixels for the top margin, then 2 for the bottom.
            this._ratio[kind.size] = (fullSize - actualSize) / Math.max(1, (actualSize - scrollbarSize - oppositeSideTrack - 4));

            handle
                .css(kind.size, scrollbarSize)
                .css(kind.position, this.element[kind.scrollPosition]() / this._ratio[kind.size]);
        },

        _getHandleHandler: function(that, calls) {
            return function(evt) {
                // store the position where the mouse was when dragging began
                // so we can calculate the relative difference later...
                var handle = $(this),
                    dragStart = evt[calls.page],
                    startPosition = handle.position()[calls.position];

                // now handle all mouse movements on the page to cause the scrollbar to change...
                $(global.document)
                    .on("mousemove.fxScrollbar", function(evt2) {
                        // set the scrollTop to the amount moved modified by the height ratio
                        // The scroll handler will take care of moving the handle for us

                        that.element[calls.scrollPosition](that._ratio[calls.size] * (evt2[calls.page] - dragStart + startPosition));
                        return false;
                    })
                    .one("mouseup.fxScrollbar", function() {
                        $(global.document).off("mousemove.fxScrollbar");
                        handle.removeClass("fx-scrollbar-active");
                        return false;
                    });

                handle.addClass("fx-scrollbar-active");

                return false;
            };
        },

        _getTrackHandler: function(that, kind) {
            var that = this,
                timerHandle = null,
                go = function(getNewPosition) {
                    if (that._trackEnter) {
                        var deltaPosition = getNewPosition();
                        
                        // We don't have to do anything if we found 0
                        if (deltaPosition) {
                            that.element[kind.scrollPosition](that.element[kind.scrollPosition]() + deltaPosition);
                        }
                    }
                };
        
            return function(evt) {
                // Keep value that stays constant as we scroll
                var $this = $(this),
                    handle = $this.find(".fx-scrollbar-handle"),
                    handleSize = handle[0][kind.clientSize],
                    actualSize = that._widget[0][kind.clientSize],
                    mouseMoveHandler,
                    
                    // goingForward variable keeps the direction we are going
                    // if we go forward, we can only go forward in this event
                    // The next mousedown will recalculate this
                    goingForward = (evt[kind.page] - $this.offset()[kind.position]) > handle.position()[kind.position],
                    
                    // The current mouse position is important so that we know
                    // if the cursor goes above the handle
                    currentMouseEvent = evt,
                    
                    // Makes the calculation delta of where we have to go
                    getNewPosition = function() {
                        var clickPosition = currentMouseEvent[kind.page] - $this.offset()[kind.position],
                            handlePosition = handle.position()[kind.position];

                        if (!goingForward && clickPosition < handlePosition) {
                            return -(actualSize /*- this._oppositeSideTrack*/);
                        } else if (goingForward && clickPosition > handlePosition + handleSize) {
                            return (actualSize /*- this._oppositeSideTrack*/);
                        }
                        
                        return 0;
                    };
                    
                    $this.on("mousemove.fxScrollbar", mouseMoveHandler = function(evt) {
                        currentMouseEvent = evt;
                    });
                    
                    
                go(getNewPosition);
                
                // Holding the track doesn't trigger the interval immediately
                // We wait a couple of milliseconds then we start our timer
                // Since only one time is running at once, we keep the same handle
                timerHandle = setTimeout(function() {
                    timerHandle = setInterval(function() { go(getNewPosition); }, 50);
                }, 400);
                
                $("body").one("mouseup", function() {
                    clearTimeout(timerHandle);
                    timerHandle = null;
                    $this.off("mousemove.fxScrollbar", mouseMoveHandler);
                    mouseMoveHandler = null;
                });
            };
        }
    });

    $(function() {
        $(".fx-scrollbar").each(function() {
            var options = global.fx.utilities.attributesToObject(this, "data-fxcontrol");
            $(this).fxScrollbar(options);
        });
    });
})(jQuery, jQuery.Widget, this);
</script>
<script>
$(function() {
    var scrollableElement = $("#scroll"),
        ul = scrollableElement.find("ul");
    for(var i = 0; i < 1000; i++) {
        if(i === 500) {
            
    ul.append("<li><input type='text' /></li>");
        }
        ul.append("<li>Test " + i + "</li>");
    }
    ul.find("input").focus();

  $("#scroll").fxScrollbar();
});
</script>
<style>
  #scroll {
    height: 200px;
  }
</style>
</head>
<body style="margin-top: 300px;">
  <div id="scroll">
    <ul>
    </ul>
  </div>
  <div id="output"></div>
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  More content<br />
  
  
  
  
</body>
</html>